19.01.03

chap6.클래스

기본타입변수값 동등 비교 연산자 == 

문자열변수 동등 비교 연산 equals() 
- 기본타입비교연산자 는 주소를 비교하는 것으로 내용을 비교하기 위해선 equals()를 사용해야함. 


대소문자무시하고 비교 가능하도록 함 
equals.IgnoreCase()
toUpperCase()-toLowerCase()

클래스 
1> 객체 분석 - 정적/동족 분석
2> 클래스 표현  - 필드변수/메소드
= 객체를 정의
class 클래스이름{
	필드변수
	생성자
	메소드
}
3> 객체 표현 - 생성  
클래스명 변수명 = new 생성자();
=> heap 영역에 지정된 클래스 복사본 : 생성된 객체 할당
=> 필드변수값 초기화 
4> 변수명.필드변수
      변수명.메소드명()


[modifier]class 클래스이름{
	[modifier]필드변수
	[modifier]메소드
	[modifier]생성자
}

Modifier
역할, 어떤 요소 앞에 붙는가

접근권한 modifier
	public
	protected
	no modifier : default 상태로, 현재 패키지 내부 사용 가능 
	private : 현재  선언 클래스 내부에서만 사용 가능
	
	권한 정도 : private < no modifier < protected < public 
	

1. static
- 변수, 메소드 앞 선언
- "정적" <--> "동적"
- 모든 객체 공통 1개값 저장 변수 앞 선언	
- 객체 내부 필드변수값 모든 객체 동일 static 변수 선언 
	class 회사원{
		int 사번 
		String 이름
		double 급여
		static String 회사명="삼성"
		
	}
	=> 회사원 객체 10명 
	회사원(100,이사원,50000,삼성)
	회사원(200,박부장,80000,삼성)
	.....
	
	1> 모든 객체 동일 1개 저장 변수   <--> non-static 객체마다 고유값 개별 저장 
	2> 모든 객체 공유
	3> 클래스명.static필드변수  <--> non-static 변수일경우 error 
	4> 객체참조변수명.static필드변수 가능 
		p1.nation == p2.nation == Person.nation
	
2. final
- 클래스, 변수, 메소드 앞 선언 
- 최종적 = 더 이상 수정 없음
- 절대 불변의 진리값, 자바 규칙으로 정해진값, 공유값 

	class A{
		final static int i = 100;
		//static final int i =100 ; //modifier 의 순서는 중요하지 않음 
	}
	
	static 과  final는 비슷한 성향을 가져 주로 같이 사용함 

3. public
- 클래스, 변수, 메소드, 생성자
- 접근의 제한이 없음. 무제한 

4. protected
- 현재 패키지 내부 + 해당 패키지를 상속(extends) 받은 클래스에서 사용 가능  

5. private 
- 현재 선언 클래스 내부에서만 사용가능
- 타 클래스에서 출력 및 변경 모두 불가능  
- 정보 은닉 

- private 선언 직접 변수로 접근하여 변경은 불가능하나
 	메소드를 활용해 전달받아 수정을 발생시킬 수 잇음 




패키지 Package
1> 자바 클래스 모음
	자바 클래스 => 1개 파일 
	패키지 => 폴더/디렉토리
	자바 플랫폼 독립적 - 1개 자바 소스 파일 작성 -> win, linux,..., 모든 환경에서  동일 동작


객체 지향 언어 조건 -> 객체지향언어 목표 : 코드 재사용  
1. 캡슐화 문법  = 연관 데이터와 기능 묶음 = 클래스 
	다른 캡술 정보 은닉 단계 조정 : 접근 modifier 활용 
2. 
3.

	
class A{
	private 변수;
	public 변수접근메소드(){
	}
}
class Main{
	A a1 = new A();
	a1.변수접근메소드();
	
}



chap7.상속
객체 지향 언어 조건 -> 객체지향언어 목표 : 코드 재사용  
1. 캡슐화 문법  = 연관 데이터와 기능 묶음 = 클래스 
	다른 캡술 정보 은닉 단계 조정 : 접근 modifier 활용
2. 상속 문법
3.

extends 사용 
	
- 상위 클래스 : super, parent
- 하위 클래스 : sub, child 
자바 클래스 단일 상속 : superclass 1개만 지정 : extends 1개 클래스명

class 학생{}
class 교직원{}
class 조교 extends 학생, 교직원 {} => X, 여러개의 클래스 상속은 불가능 ==> 인터페이스 활용 


기존 클래스 정의 : 포함 내용 다른 클래스 필요
- 자바 설계 요령 교재 = 자바 디자인 패턴 
1> is-a관계 (이다) : 상속
2> has-a관계 (가지다) : 객체생성

상속 필드변수
1. 상위 변수, 메소드들은 하위 클래스에서 사용이 가능 
2. private 변수는 하위 클래스에서 사용 불가능    
3. 상위, 하위 클래스 동일명 변수 존재
	하위클래스 선언 변수 우선 사용
	상위클래스 선언 변수 사용 - super 키워드 사용 

상속 생성자
1> 명시적으로 extends 작성하지 않으면 Object 자동 상속 구조
2> 자바 모든 클래스 생성자 첫문장 super() 자동 정의
3> 하위 객체 생성시에는 상위 객체 생성
4> 상위 객체 먼저 생성 
5> 상위 생성자 : 매개변수 없는 생성자 호출 

==> 하위 클래스 객체 생성시 자동 상위 클래스 객체 생성 

	super() : 상위 객체 의미 키워드
		- super.상위필드변수 : 상위, 하위 클래스의 변수 이름 구분 
		- super.상위메소드 : 상위, 하위 클래스의 메소드 이름 구분 
		- super() : 생성자 첫문장 자동 정의, 상위 매개변수없는 생성자 호출
		- super(매개변수) : 생성자 첫문장 사용자 정의, 상위 매개변수 정의한 생성자 호출
		
		
	this(): 현재 자신 객체 의미 키워드
		- this.필드변수 : 매개변수와 필드변수 이름 구분
		- this([매개변수전달]) : 자신 포함 다른 생성자 호출 
	



	