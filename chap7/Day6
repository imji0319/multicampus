19.01.04

chap7. 상속

메소드 overloading
- 1개의 클래스 내부에 같은 이름의 메소드 여러 개 정의, 다만 매개변수 개수, 타입, 순서 다르게 정의
- 중복 정의

메소드 overriding
- 우선시하다
- 상속 관계에 있는 2개의 클래스 내부에 같은 이름의 메소드 정의,
- 매개변수 같고, 리턴타입이 동일해야하며 modifier 같거나 더 넓어야 함

<구분 : 메소드, 생성자 표현 가능 문장>
super.상위변수
super.상위메소드

<생성자호출: 생성자 첫 문장>
super() : 상위 매개변수 없는 생성자 호출 , 자동 정의
super(매개변수) : 상위 매개변수 있는 생성자 호출, 사용자 정의

객체 지향 언어 조건
1. 캡슐화 - 정보 은닉
2. 상속
3. 다형성(polymorphism) 
- 메소드 overloading : 매개변수 전달 - 다르다
- 메소드 overriding : 하위 수정 메소드 존재
==> 같은 이름 : 여러 결과 


final = 수정 불가능
1> final 변수 : 값 수정 불가능 = 상수
2> final 메소드 : 메소드오버라이딩 금지
3> final 클래스 : 상속 금지 -> 메소드 오버라이딩 불가
==> 상속와 오버라이딩 금지 ===> 객체생성과 메소드 호출만 사용 가능 ㄴ
	
다른 클래스를 활용하는 방법
1. 상속
2. 객체 생성
	

abstract : 추상적, 구체X
1> abstract 메소드 : 선언부만 있고 구현부가 없는 메소드 앞에 선언
2> abstract 클래스 : abstract 메소드 최소 1개 이상 존재할 때 선언 
	- 객체 생성 불가능
	- abstract 클래스는 상속 의무화 
	- 하위 클래스에서 오버라이딩 의무화 
	- final 과 같이 사용 불가능 ( final는 상속 불가능, abstract는 상속 의무로 의미 모순)
	
	abstract class 도형{
		abstract void 면적();
		abstract void 둘레();
	} 
	
	class 사각형 extends 도형{
		void 면적() {가로*세로};     //abstract 클래스를 상속할 때 오버라이딩
		void 둘레() {2*(가로+세로)}; 
	}
	
	===> abstract 클래스는 전체 프로그램에서 각 클래스별 
	구현해야할 "공통 기능" 명세서 를 의미한다고 할 수 있음 (선언부)
	
	각각 구현하더라도 동일하고 공통된 방식으로 구현이 가능해짐























	
	
	
	
	